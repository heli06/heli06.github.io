<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>《你不知道的JS》复习 | 鸑鷟的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文是我在看《你不知道的JS》时随手摘录的，打算面试前再看两眼回忆用。可能没什么逻辑，见谅~
作用域与闭包
尽管JavaScript一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言
在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前首先被处理
声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也不会被提升
函数声明和变量声明都会被提升。但是，函数会首先">
<meta property="og:type" content="article">
<meta property="og:title" content="《你不知道的JS》复习">
<meta property="og:url" content="http://heli06.github.io/category/《你不知道的JS》复习/index.html">
<meta property="og:site_name" content="鸑鷟的博客">
<meta property="og:description" content="本文是我在看《你不知道的JS》时随手摘录的，打算面试前再看两眼回忆用。可能没什么逻辑，见谅~
作用域与闭包
尽管JavaScript一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言
在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前首先被处理
声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也不会被提升
函数声明和变量声明都会被提升。但是，函数会首先">
<meta property="og:updated_time" content="2018-03-08T08:52:49.439Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《你不知道的JS》复习">
<meta name="twitter:description" content="本文是我在看《你不知道的JS》时随手摘录的，打算面试前再看两眼回忆用。可能没什么逻辑，见谅~
作用域与闭包
尽管JavaScript一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言
在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前首先被处理
声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也不会被提升
函数声明和变量声明都会被提升。但是，函数会首先">
  
    <link rel="alternative" href="/atom.xml" title="鸑鷟的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/touxiang.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">鸑鷟</a></h1>
		</hgroup>

		
		<p class="header-subtitle">蛟龙虽困，不资凡鱼。鸑鷟虽孤，不匹鹜雏。</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/技术研究/">技术研究</a></li>
				        
							<li><a href="/tags/项目/">项目</a></li>
				        
							<li><a href="/tags/文学/">文学</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">大连理工大学2015年入学，软件工程（日语强化）本科在读，新手WEB前端</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">鸑鷟</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="null/img/touxiang.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">鸑鷟</h1>
			</hgroup>
			
			<p class="header-subtitle">蛟龙虽困，不资凡鱼。鸑鷟虽孤，不匹鹜雏。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/技术研究/">技术研究</a></li>
		        
					<li><a href="/tags/项目/">项目</a></li>
		        
					<li><a href="/tags/文学/">文学</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-《你不知道的JS》复习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/category/《你不知道的JS》复习/" class="article-date">
  	<time datetime="2018-02-28T09:46:49.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《你不知道的JS》复习
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术研究/">技术研究</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是我在看《你不知道的JS》时随手摘录的，打算面试前再看两眼回忆用。可能没什么逻辑，见谅~</p>
<h3 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h3><ul>
<li>尽管<code>JavaScript</code>一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言</li>
<li>在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前<strong>首先</strong>被处理</li>
<li>声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也<strong>不会</strong>被提升</li>
<li>函数声明和变量声明都会被提升。但是，函数会首先被提升，然后才是变量</li>
</ul>
<a id="more"></a>
<hr>
<h3 id="this-与对象原型"><a href="#this-与对象原型" class="headerlink" title="this 与对象原型"></a>this 与对象原型</h3><ul>
<li><code>this</code>实际上是在函数被调用时建立的一个绑定，它指向什么是完全由函数被调用的调用点来决定的</li>
<li><code>bind(..)</code>返回一个硬编码的新函数，它使用你指定的this环境来调用原本的函数</li>
<li>许多函数都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的<code>this</code>而不必非得使用<code>bind(..)</code></li>
<li><code>new</code>是函数调用可以绑定<code>this</code>的最后一种方式</li>
<li>绑定的优先级，new绑定&gt;明确绑定或硬绑定&gt;隐含绑定&gt;默认绑定，除非传递的绑定参数是<code>undefined</code>或<code>null</code></li>
<li>创建<strong>完全为空的对象</strong>的最简单方法就是<code>Object.create(null)</code></li>
<li>箭头函数从封闭它的（<code>function</code>或<code>global</code>）作用域采用<code>this</code>绑定,其本质是用被广泛理解的词法作用域来禁止了传统的<code>this</code>机制</li>
<li>一个常见的错误论断是“JavaScript中的一切都是对象”。这明显是不对的</li>
<li><code>function</code>是对象的一种子类型（技术上讲，叫做“可调用对象”）</li>
<li>尽可能地使用字面形式的值，而非使用构造的对象形式</li>
<li><code>null</code>和<code>undefined</code>没有对象包装的形式，仅有它们的基本类型值。相比之下，<code>Date</code>的值<strong>仅可以</strong>由它们的构造对象形式创建，因为它们没有对应的字面形式。无论使用字面还是构造形式，<code>Object</code>，<code>Array</code>，<code>Function</code>，和<code>RegExp</code>都是对象</li>
<li>ES6加入了<strong>计算型属性名</strong></li>
<li>在JavaScript中，“函数”和“方法”是可以互换使用的</li>
<li>在<code>Object.assign(..)</code>中发生的复制是单纯的=式赋值，所以任何在源对象属性的特殊性质（比如writable）在目标对象上都不会保留</li>
<li>对象可被防止扩展、封印、冻结</li>
<li>对于访问器描述符，它的<code>value</code>和<code>writable</code>性质没有意义</li>
<li>有许多方法区分可枚举与不可枚举属性</li>
<li><code>for..of</code>循环要求被迭代的东西提供一个迭代器对象</li>
<li>数组拥有内建的<code>@@iterator</code>。<code>@@iterator</code>本身不是迭代器对象,而是一个返回迭代器对象的<strong>方法</strong></li>
<li><code>JavaScript</code>实际上<strong>不拥有</strong>类。一般来讲，在JS中模拟类通常会比解决当前<strong>真正</strong>的问题埋下更多的坑</li>
<li><code>in</code>操作符将会检查对象的整个链条上属性是否存在</li>
<li>属性的隐式遮蔽很令人头疼</li>
<li>函数不是构造器，但是当且仅当<code>new</code>被使用时，函数调用是一个“构造器调用”</li>
</ul>
<p>这块内容很复杂，作者的想法挺反主流……许多大幅段落很精彩但未能摘录，先这样放着吧……</p>
<hr>
<h3 id="类型与文法"><a href="#类型与文法" class="headerlink" title="类型与文法"></a>类型与文法</h3><ul>
<li><code>typeof null === &quot;object&quot;; // true</code></li>
<li><code>typeof</code>常用于构建不带有抛出错误的检查</li>
<li>要小心创建“稀散”的<code>array</code></li>
<li>如果一个可以被强制转换为10进制<code>number</code>的<code>string</code>值被用作键的话，它会认为你想使用<code>number</code>索引而不是一个<code>string</code>键</li>
<li>最好不要向<code>array</code>添加<code>string</code>键/属性</li>
<li>如果<code>slice()</code>没有用其他额外的参数调用，它会具有复制<code>array</code>的效果</li>
<li><code>string</code>上没有一个方法是可以原地修改它的内容的，而是创建并返回一个新的<code>string</code></li>
<li>JS中，“整数”只是没有小数部分的小数值，42.0和42一样是“整数”</li>
<li><code>null</code>是一个特殊的关键字，不是一个标识符。<code>undefined</code>（不幸地<strong>是</strong>一个标识符,可以被赋值</li>
<li><code>NaN</code>的类型是<code>number</code></li>
<li><code>window.isNaN(..)</code>工具有重大缺陷，最好使用<code>Number.isNaN(..)</code></li>
<li>JS中可以除以零，结果是<code>Infinity</code>（用正数除）或<code>-Infinity</code>（用负数除）</li>
<li><code>Infinity / Infinity</code>在JS中的结果为<code>NaN</code></li>
<li>JavaScript拥有普通的零0（也称为正零+0）和一个负零-0</li>
<li>如果负零转换为字符串，结果为”0”，但从数字转为字符串不会撒谎</li>
<li>在ES6中，<code>Object.is(..)</code>可用于测试两个值的绝对等价性，而没有任何例外</li>
<li>引用与其他语言中的引用/指针不同——它们从不指向其他的变量/引用，而仅指向底层的值</li>
<li>永远也不要做<code>new String(&quot;abc&quot;)</code>这样的事情</li>
<li><code>Array(..)</code>构造器不要求在它前面使用<code>new</code>关键字</li>
<li><code>Symbol</code>不是<code>object</code>，它们是简单的基本标量</li>
<li><code>Symbol(..)</code>原生类型“构造器”不能与<code>new</code>一起使用</li>
<li><code>Function.prototype</code>是一个空函数，<code>RegExp.prototype</code>是一个“空”正则表达式（也就是不匹配任何东西），而<code>Array.prototype</code>是一个空数组，这使它们成了可以赋值给变量的，很好的“默认”值</li>
<li><code>toJSON()</code>应当被翻译为：“变为一个适用于字符串化的JSON安全的值”</li>
<li><code>toNumber()</code>很有趣</li>
<li><code>falsy</code>对象是历史遗留问题</li>
<li>各种类型的转换方式要详细看</li>
<li>一个<code>&amp;&amp;</code>或<code>||</code>操作符产生的值不见得是<code>Boolean</code>类型。这个产生的值将总是两个操作数表达式其中之一的值。这些特性使得它有很多有趣的用法</li>
<li><code>Symbol</code>是个很大的例外</li>
<li>永远不要在任何情况下，使用<code>== true</code>或<code>== false</code></li>
<li><code>ToPrimitive</code>很奇怪</li>
<li>强制转换存在诸多例外情况，比较时发生的转换也很奇葩</li>
<li>所有语句都有完成值（即使这个值只是<code>undefined</code>）</li>
<li><code>var a = b = 42</code>的写法是错误的。它要么抛出一个错误（严格模式），要么创建一个全局变量（非严格模式）</li>
<li>JS的确支持一种有限的，特殊形式的<code>goto</code>：标签跳转</li>
<li><code>var { a , b } = ..</code>是ES6解构赋值的一种形式</li>
<li>右结合性的意思<strong>不是</strong>从右到左求值，它的意思是从右到左<strong>分组</strong></li>
<li><code>typeof</code>有一个例外，它对于未声明的变量是安全的，但是对于TDZ引用却没有这样的安全例外</li>
<li>当使用ES6的参数默认值时，如果你省略一个参数，或者你在它的位置上传递一个<code>undefined</code>值的话，就会应用这个默认值</li>
<li>绝不同时引用一个被命名参数和它相应的<code>arguments</code>值槽</li>
<li>（由于浏览器的遗留行为）使用<code>id</code>属性创建<code>DOM</code>元素会创建同名的全局变量</li>
</ul>
<hr>
<h3 id="异步与性能"><a href="#异步与性能" class="headerlink" title="异步与性能"></a>异步与性能</h3><ul>
<li>在ES6中，在事件轮询队列之上引入了一层新概念，称为“工作队列”</li>
<li>链式调用<code>.then(..)</code>创建了另一个<code>promise</code>。虽没有在这第二个<code>then(..)</code>的末尾链接任何操作，它也已经创建了另一个<code>promise</code>，可以监听/使用它</li>
<li>因为<code>Promise</code>一旦被解析就是外部不可变的，所以现在将这个值传递给任何其他团体都是安全的，而且它不会被意外或恶意地被修改</li>
<li>“如果它看起来像一只鸭子，并且叫起来像一只鸭子，那么它一定是一只鸭子”</li>
<li>当一个<code>Promise</code>被解析时，所有在<code>then(..)</code>上注册的回调都将被立即，按顺序地，在下一个异步机会时被调用，而且没有任何在这些回调中发生的事情可以影响/推迟其他回调的调用</li>
<li>绝不应该依靠任何跨<code>Promise</code>的回调顺序/排程</li>
<li><code>Promise</code>使用一个称为“竞赛（race）”的高级抽象</li>
<li><code>Promise.resolve(..)</code>会接受任何<code>thenable</code>，而且将它展开直至非<code>thenable</code>值。但你会从<code>Promise.resolve(..)</code>那里得到一个真正的，纯粹的<code>Promise</code>，一个你可以信任的东西</li>
<li>可以将多个<code>Promise</code>串联在一起来表达一系列的异步步骤</li>
<li>错误持续地在<code>Promise</code>链上传播，直到遇到一个明确定义的拒绝处理器</li>
<li>如果一个Promise被拒绝，可以选择明确地处理这个报告（使用<code>defer()</code>）</li>
<li><code>Promise.all([..])</code>和<code>Promise.race([..])</code>是相对的</li>
<li>一个<code>generator</code>的声明被格式化为<code>function* foo() {..}</code></li>
<li>一般来说，你所拥有的<code>next(..)</code>调用的数量，会比你所拥有的<code>yield</code>语句的数量多一个</li>
<li><code>yield ..</code>和<code>next(..)</code>一起成对地在<code>generator</code>运行期间构成了一个双向消息传递系统</li>
<li>在ES6中，从一个<code>iterable</code>中取得一个迭代器的方法是，<code>iterable</code> 上必须有一个函数，它的名称是特殊的ES6符号值<code>Symbol.iterator</code></li>
<li>当调用<code>it.return(..)</code>时，它会立即终结<code>generator</code>，从而运行<code>finally</code>从句。而且，它会将返回的<code>value</code>设置为你传入<code>return(..)</code>的任何东西。也不必使用<code>break</code>，因为<code>generator</code>的迭代器会被设置为<code>done:true</code>，<code>for..of</code>循环会在下一次迭代时终结</li>
<li>我们将异步性，特别是<code>Promise</code>，作为一种实现细节</li>
<li>“基准分析与调优”这一章很有趣，提供了若干统计工具</li>
<li>大量的针对微小操作的基准分析结果——比如<code>++x</code>对<code>x++</code>的神话——完全是<strong>伪命题</strong></li>
<li>应当测试真实的，有意义的代码段，并且在最接近你实际能够期望的真实条件下进行</li>
<li>虽然程序的关键路径性能非常重要，但它不是唯一的因素。在几种性能上大体相似的选择中，可读性应当是另一个重要的考量</li>
<li>尾部调用优化（TCO）是一个ES6要求的优化机制</li>
<li><code>JavaScript</code><strong>当前</strong>并没有任何特性可以支持多线程运行，但是浏览器等环境可以很容易地提供多个JavaScript引擎实例，每个都在自己的线程上，并允许你在每个线程上运行不同的程序</li>
<li>在<code>Worker</code>内部，不能访问主程序的任何资源，但可以实施网络操作和设置定时器等</li>
<li>可以创建一个单独的中心化<code>Worker</code>，网站或应用的所有网页实例可以共享它</li>
<li><code>SIMD</code>提议将CPU级别的并行数学操作映射到JavaScriptAPI上来提供高性能数据并行操作</li>
<li><code>asm.js</code>描述了一个JavaScript的小的子集，它回避了JS中不易优化的部分（比如垃圾回收与强制转换）并让JS引擎通过主动优化识别并运行这样的代码</li>
</ul>
<h3 id="ES6与未来"><a href="#ES6与未来" class="headerlink" title="ES6与未来"></a>ES6与未来</h3><ul>
<li>在一个<code>let ..</code>声明/初始化之前访问一个用<code>let</code>声明的变量会导致一个错误，而对于<code>var</code>声明来说这个顺序无关紧要（除了文体上的区别）</li>
<li>值不会因为<code>const</code>而冻结或不可变，只是它的赋值被冻结了</li>
<li>块作用域内的函数声明会被提升</li>
<li><code>...</code>经常扮演<code>apply(..)</code>方法的简约语法替代品</li>
<li>另一种<code>...</code>的用法常见于一种实质上相反的操作；与将值散开不同，<code>...</code>将一组值<strong>收集</strong>到一个数组中</li>
<li>默认值表达式是被懒惰地求值的，这意味着他们仅在被需要时运行</li>
<li>结构、计算型属性名和对象属性复制模式可以联用</li>
<li>对于对象解构形式来说，当我们省略了<code>var/let/const</code>声明符时，就必须将整个赋值表达式包含在()中，否则左手边作为语句第一个元素的<code>{..}</code>将被视为一个语句块而不是一个对象</li>
<li>可以不使用临时变量来解决传统的“交换两个变量”的问题：<code>[y,x]=[x,y];</code></li>
<li>插值型字符串字面量的一个真正的好处是他们允许被分割为多行</li>
<li>在一个插值型字符串字面量中，任何合法的表达式都被允许出现在<code>${..}</code>内部，包括函数调用，内联函数表达式调用，甚至是另一个插值型字符串字面量</li>
<li>一个标签型字符串字面量像是一个在插值表达式被求值之后，但是在最终的字符串被编译之前的处理步骤，允许你在从字面量中产生字符串的过程中进行更多的控制</li>
<li>ES6带来了一个内建函数，它可以用做字符串字面量的标签：<code>String.raw(..)</code></li>
<li>在短的内联函数表达式的地方采用<code>=&gt;</code>，但保持一般长度的主函数原封不动</li>
<li><code>for..in</code>循环遍历数组a中的键/索引，而<code>for..of</code>循环遍历a中的值</li>
<li>在<code>for (XYZ of ABC)..</code>中，XYZ子句既可以是一个赋值表达式也可以是一个声明</li>
<li>新的ES6数字字面形式：<code>var dec = 42,oct = 0o52,hex = 0x2a,bin = 0b101010;</code></li>
<li>如果一个迭代器也是可迭代对象，它就可以与<code>for..of</code>循环一起使用</li>
<li>扩散操作符<code>...</code>将完全耗尽一个迭代器</li>
<li><code>yield ..</code>与<code>a = 3</code>这样的赋值表达式拥有相同的“表达式优先级”</li>
<li><code>generator</code>实际上只是状态机逻辑的简单语法</li>
<li>任何你没有使用<code>export</code>标记的东西将在模块作用域的内部保持私有</li>
<li>与对象字面量不同的是，在一个<code>class</code>内容的部分没有逗号分隔各个成员</li>
<li>一个<code>thenable</code>没有一个纯粹的<code>Promise</code>那么可信</li>
<li>类型化数组使用类似数组的语义提供对二进制数据的结构化访问</li>
<li>制造一个<code>map</code>的拷贝十分简单：<code>var m2 = new Map( m.entries() );</code>或<code>var m2 = new Map( m );</code></li>
<li><code>WeakMap</code>（仅）接收对象作为键。这些对象被<strong>弱持有</strong>，如果对象本身被垃圾回收，那么在<code>WeakMap</code>中的记录也会被移除</li>
<li><code>WeakMap</code>没有<code>size</code>属性和<code>clear()</code>方法</li>
<li><code>WeakMap</code>只弱持有它的键，而不是它的值</li>
<li>一个<code>WeakSet</code>弱持有它的值（不存在真正的键）</li>
<li><code>WeakSet</code>的值必须是对象，在<code>set</code>中被允许的基本类型值是不行的</li>
<li><code>Array.of(..)</code>作为数组首选的函数型构造器取代了<code>Array(..)</code>，因为<code>Array.of(..)</code>没有那种单数字参数值的情况</li>
<li><code>Array.from(..)</code>从不产生空值槽</li>
<li><code>Array.from(..)</code>的第二个参数值是一个映射函数</li>
<li><code>Array#copyWithin(..)</code>是一个对所有数组可用的新修改器方法</li>
<li><code>Array#fill(..)</code>方法原生地支持使用一个指定的值来完全地（或部分地）填充一个既存的数组</li>
<li><code>find(..)</code>从数组检索中给出匹配的值。接收一个可选的第二参数</li>
<li><code>findIndex(..)</code>可寻找匹配的值的位置索引</li>
<li><code>Array</code>提供了与集合相同的迭代器方法</li>
<li>想要严格地识别<code>NaN</code>或<code>-0</code>值的情况下，<code>Object.is(..)</code>是现在的首选方式</li>
<li><code>Object.setPrototypeOf(..)</code>工具，它为了<strong>行为委托</strong>的目的（意料之中地）设置一个对象的<code>[[Prototype]]</code></li>
<li><code>Object.assign(..)</code>将一个对象的属性拷贝/混合到另一个对象中。非枚举属性和非自身属性会被忽略</li>
<li><code>Math</code>、<code>String</code>和<code>Number</code>添加了不少有用的函数和属性</li>
<li>元编程是针对程序本身的行为进行操作的编程</li>
<li><code>function</code>的<code>name</code>属性是啥是个谜</li>
<li><code>new.target</code>用来从一个构造器调用内部判定原来的<code>new</code>的目标是什么</li>
<li>可以通过设置<code>Symbol.iterator</code>属性来为任意对象定义我们自己的迭代器逻辑</li>
<li><code>ToPrimitive</code>抽象强制转换操作</li>
<li>代理<code>proxy</code>是一种由你创建的特殊的对象，它“包”着另一个普通的对象</li>
<li><code>Reflect</code>对象是一个普通对象（就像<code>Math</code>），不是其他内建原生类型那样的函数/构造器。它持有对应于你可以控制的各种元编程任务的静态函数</li>
<li>在ES6中，罗列直属属性的属性是由<code>[[OwnPropertyKeys]]</code>算法定义的，这种顺序仅对<code>Reflect.ownKeys(..)</code>有保证</li>
<li>所有四种机制（<code>Reflect.enumerate(..)</code>，<code>Object.keys(..)</code>，<code>for..in</code>，和<code>JSON.stringify(..)</code>）都同样将与依赖于具体实现的顺序相吻合</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/category/JavaScript书籍复习合集/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          JavaScript书籍复习合集
        
      </div>
    </a>
  
  
    <a href="/category/Java基础学习笔记和J2EE高级编程笔记合集/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java基础学习笔记和J2EE高级编程笔记合集</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="《你不知道的JS》复习" data-title="《你不知道的JS》复习" data-url="http://heli06.github.io/category/《你不知道的JS》复习/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"heli06"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 鸑鷟
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>